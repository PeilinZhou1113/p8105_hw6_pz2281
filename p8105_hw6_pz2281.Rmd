---
title: "p8105_hw6_pz2281"
author: "Peilin Zhou"
output: github_document
---

```{r message = FALSE}
library(tidyverse)
library(modelr)
library(mgcv)
library(ggplot2)
```

## Problem 1

Import data for modelling

```{r}
birth_data = read.csv("./data/birthweight.csv") %>%
  as_tibble()
```

Clean the data. First check if there are missing values.

```{r}
birth_data %>% 
  summarise_all(~ sum(is.na(.)))
#no missing values


birth_data %>% 
  select(babysex, frace, mrace, malform) %>% 
  summarise_all(list(~n_distinct(.)))

#clean the data

clean_birth = birth_data %>% 
  mutate_at(c("babysex", "frace", "malform", "mrace", "fincome"), as.factor) %>% 
  mutate_if(is.integer, as.double) 
#  rename(baby_sex = babysex, baby_head = bhead, baby_length = blength, baby_weight = bweight, m_del)

```

To select independent variables for the model, I used scatter plots to observe the potential association between birth weight and other variables.

Plots for birth weight against numerical variables:
```{r}
clean_birth %>%
  select_if(is.numeric) %>% 
  gather(-bwt, key = "var", value = "value") %>% 
  ggplot(aes(x = value, y = bwt)) +
    geom_point() +
    geom_smooth(method = lm, se = FALSE) +
    facet_wrap(~ var, scales = "free") +
    theme_bw() +
    labs(
    title = "Scatter Plots of Birth Weight Against Other Numeric Variables",
    x = "Numeric Variables",
    y = "Birth Weight"
    )
```

From the plots, it can be observed that positive associations potentially exist  between birth weight and baby’s head circumference at birth, baby’s length at birth, gestational age in weeks, mother’s height gain during pregnancy. These variables can be selected as predictors of the model.

Plots for birth weight against categorical variables.

```{r}
clean_birth %>%
  select_at(c("bwt", "babysex", "frace", "malform", "mrace")) %>% 
  gather(-bwt, key = "var", value = "value") %>% 
  ggplot(aes(x = value, y = bwt)) +
    geom_point() +
    geom_smooth(method = lm, se = FALSE) +
    facet_wrap(~ var, scales = "free") +
    theme_bw() +
  labs(
    title = "Scatter Plots of Birth Weight Against Other Categorical Variables",
    x = "Categorical Variables",
    y = "Birth Weight"
  )
```

From the scatter plots, there is no clear relationship between birth weight and other categorical variables, but a visually noticeable difference in birth weight does exists based on father/mother's race, or the presence of malformations.

Based on the above observations, my hypothesized model contains 5 numeric variables and 2 categorical variables which have shown potential relationship with birth weight.

Hypothesized Model:

bwt = bhead + blength + delwt + gaweeks + wtgain + frace + mrace

```{r}
my_fit = lm(bwt ~ bhead + blength + gaweeks + wtgain + frace + mrace, data = clean_birth)
broom::glance(my_fit) %>% knitr::kable()
broom::tidy(my_fit) %>% knitr::kable()
```

However, I also want to use the step-wise model selection method(bi-directional) to fit a model and compare it with my hypothesized model. The one that has higher adjusted R^2 value would be selected as the hypothesized model.

Step-wise model selection:
```{r}
fit_intercept = lm(bwt ~ 1, data = clean_birth)
fit_all = lm(bwt ~ ., data = clean_birth)
fit_stepwise = step(fit_intercept, direction = 'both', scope = formula(fit_all), trace = 0)
broom::glance(fit_stepwise) %>% knitr::kable()
broom::tidy(fit_stepwise) %>% knitr::kable()
```

As shown in the table, the model fitted using step-wise selection has higher R^2 values. So the model I would use as hypothesized model is fit_stepwise.

Plot of model residuals against fitted values:
```{r}
clean_birth %>% 
  modelr::add_residuals(fit_stepwise) %>% 
  modelr::add_predictions(fit_stepwise) %>% 
  ggplot(aes(x = pred, y = resid)) +
  geom_point() +
  labs(
    title = "Fitted Values vs Residuals of the Model",
    y = "Residuals",
    x = "Predicted Values"
  )
```

Most of the points are symmetrically distributed and clustered around 0 on the y-axis. However, we can see that when the predicted values are small, the residuals tend to have extreme values.

Next, compare fit_stepwise model with two prespecified models:

Fit two models:

```{r}
fit_linear = lm(bwt ~ blength + gaweeks, data = clean_birth)
broom::tidy(fit_linear) %>% knitr::kable()
broom::glance(fit_linear) %>% knitr::kable()

fit_interaction = lm(bwt ~ bhead * blength + bhead * babysex + blength * babysex + bhead * babysex * blength, data = clean_birth)
broom::tidy(fit_interaction) %>% knitr::kable()
broom::glance(fit_interaction) %>% knitr::kable()
```

Compare the models and plot the RMSE distributions:
```{r}
set.seed(1)
cv_df = crossv_mc(clean_birth,100) %>% 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble)
  ) %>% 
  mutate(
    fit_stepwise = map(train, ~lm(bwt ~ bhead + blength + gaweeks + wtgain + frace + mrace, data = .x)),
    fit_linear = map(train, ~lm(bwt ~ blength + gaweeks, data = .x)),
    fit_interaction = map(train, ~lm(bwt ~ bhead * blength + bhead * babysex + blength * babysex + bhead * babysex * blength, data = .x))
  ) %>% 
  mutate(
    rmse_fit_stepwise = map2_dbl(fit_stepwise, test, ~rmse(model = .x, data = .y)),
    rmse_fit_linear    = map2_dbl(fit_linear, test, ~rmse(model = .x, data = .y)),
    rmse_fit_interaction    = map2_dbl(fit_interaction, test, ~rmse(model = .x, data = .y)),
  )

cv_df %>% 
  select(starts_with("rmse")) %>% 
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin() +
  labs(
    title = "Root-Mean-Squared-Deviation Distributions of Three Models"
  )
```

Based on the distributions of RMSE values from the three models, we can clearly see that the model with the fewest predictors, in other words, the fit_linear model performs the worst. And the hypothesized model, fit_stepwise, performs better than the one with interactions, but there is some overlap between the two distributions of rmse of these two models. So, it might be better to compute the average rmse to have clearer picture:

```{r}
cv_df %>% 
  select(starts_with("rmse")) %>% 
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  group_by(model) %>% 
  summarise(
    avg_rmse = mean(rmse)
  ) %>% knitr::kable()
```

Now, it is obvious that the average rmse is lowest for the hypothesized model(fit_stepwise). This model performs best comparing to the other two models.


